// СТИЧ НАЗАР ИВАНОВИЧ ИВТ-22
#include <iostream>  // Подключаем библиотеку для ввода/вывода данных
#include "ntreecor.h"  // Подключаем заголовочный файл с реализацией дерева
using namespace std;  // Используем пространство имен std для удобства работы с стандартными функциями
using namespace NTree;  // Используем пространство имен NTree для работы с деревом

//ГЛАВНАЯ ФУНКЦИЯ
int main() {  
    setlocale(LC_ALL, "russian");  // Устанавливаем локализацию для корректного вывода русских символов
    AssertCheck();  // Вызываем тестовую функцию для проверки работы дерева 
    // Создаем дерево с корневым узлом, содержащим данные 0
    NTree::NaryTree<int> tree(0);  // Создаем объект дерева с корневым узлом, хранящим число 0

    // Добавляем три дочерних узла к корневому узлу
    tree.addChild(tree.root, 1);  // Добавляем дочерний узел с данными 1 к корневому узлу
    tree.addChild(tree.root, 2);  // Добавляем дочерний узел с данными 2 к корневому узлу
    tree.addChild(tree.root, 3);  // Добавляем дочерний узел с данными 3 к корневому узлу

    // Добавляем три дочерних узла к каждому дочернему узлу корневого узла вручную

    // Добавляем потомков для узла с данными 1
    NTree::NaryTreeNodeStruct<int>* node1 = tree.findNode(tree.root, 1);  // Ищем узел с данными 1
    tree.addChild(node1, 11);  // Добавляем первого потомка узла 1
    tree.addChild(node1, 12);  // Добавляем второго потомка узла 1
    tree.addChild(node1, 13);  // Добавляем третьего потомка узла 1

    // Добавляем потомков для узла с данными 2
    NTree::NaryTreeNodeStruct<int>* node2 = tree.findNode(tree.root, 2);  // Ищем узел с данными 2
    tree.addChild(node2, 21);  // Добавляем первого потомка узла 2
    tree.addChild(node2, 22);  // Добавляем второго потомка узла 2
    tree.addChild(node2, 23);  // Добавляем третьего потомка узла 2

    // Добавляем потомков для узла с данными 3
    NTree::NaryTreeNodeStruct<int>* node3 = tree.findNode(tree.root, 3);  // Ищем узел с данными 3
    tree.addChild(node3, 31);  // Добавляем первого потомка узла 3
    tree.addChild(node3, 32);  // Добавляем второго потомка узла 3
    tree.addChild(node3, 33);  // Добавляем третьего потомка узла 3

    // Добавляем потомка для узла с данными 32
    NTree::NaryTreeNodeStruct<int>* node32 = tree.findNode(tree.root, 32);  // Ищем узел с данными 32
    tree.addChild(node32, 41);  // Добавляем потомка с данными 41

    // Выводим дерево на экран
    std::cout << "Дерево:\n";  // Сообщение перед выводом дерева
    tree.printNode(tree.root);  // Выводим дерево с помощью функции, начиная с корневого узла

    // Подсчет уровней в дереве
    int levels = tree.countLevels(tree.root);  // Вычисляем количество уровней в дереве
    std::cout << "\nКоличество уровней в дереве: " << levels << std::endl;  // Выводим количество уровней

    // Подсчет общего количества узлов в дереве
    int totalNodes = tree.countNodes(tree.root);  // Вычисляем общее количество узлов в дереве
    std::cout << "Общее количество узлов в дереве: " << totalNodes << std::endl;  // Выводим количество узлов

    // Поиск узла с определенными данными
    int searchValue = 12;  // Значение для поиска узла
    NTree::NaryTreeNodeStruct<int>* foundNode = tree.findNode(tree.root, searchValue);  // Ищем узел с данными 12
    if (foundNode) {  // Если узел найден
        std::cout << "\nУзел с данными " << searchValue << " найден." << std::endl;  // Сообщаем, что узел найден
    }
    else {  // Если узел не найден
        std::cout << "\nУзел с данными " << searchValue << " не найден." << std::endl;  // Сообщаем, что узел не найден
    }

    // Удаление узла с данными 12
    bool deleted = tree.deleteNode(tree.root, searchValue);  // Пытаемся удалить узел с данными 12
    if (deleted) {  // Если узел был удален
        std::cout << "\nУзел с данными " << searchValue << " был удален.\n";  // Сообщаем, что узел был удален
    }
    else {  // Если узел не найден для удаления
        std::cout << "\nУзел с данными " << searchValue << " не найден для удаления.\n";  // Сообщаем, что узел не найден
    }

    // Повторный вывод дерева после удаления узла
    std::cout << "\nДерево после удаления узла " << searchValue << ":\n";  // Сообщаем, что дерево будет выведено после удаления
    tree.printNode(tree.root);  // Повторно выводим дерево

    return 0;  // Возвращаем 0, что означает успешное выполнение программы
}
